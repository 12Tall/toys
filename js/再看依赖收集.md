# 再看依赖收集  

## 0. 简单的发布者-订阅者(观察者)模式  

如果一个对象的某些信息被修改了，就要通知相关的人。比如商品降价信息要及时通知到`收藏`了的客户。  

代码实现：  

```ts
// listener.ts

/********** 定义接口 ************/
/**
 * 监听者接口
 */
interface IListener {
    // 接收通知，更新
    update(result: string): void;
}

/**
 * 被监测者接口
 */
interface IObserverable {
    // 属性
    name: string;
    // 监听器，因为可能不止一个，所以采用数组
    listeners: Array<IListener>;
    // 添加监听器
    addListener(listener: IListener): void;
    // 发布更新
    notify(): void;
}

/**
 * 将对象的属性定义为可观测的
 * @param obj 对象
 * @param prop 属性
 * @param val 值
 * @summary 其实这里还可以再传入一个回调函数，或者
 * 给notify() 传入一个值，用于可能会用到的自定义操作
 */
function defineReactive(obj: IObserverable, prop: string, val: any): void {
    Object.defineProperty(obj, prop, {
        enumerable: true,   // 该属性可以被枚举
        configurable: true, // 该属性的修饰符可以被修改
        get() {
            return val;
        },
        set(newVal) {
            // 如果值被改变，则让对象发布更新
            if (newVal !== val) {
                val = newVal;
                obj.notify();
            }
        }
    });

    return;
}

/************** 接口的实现 ****************/

// 注意是var 而不是class，因为js 本身没有类这个概念吧
// 定义监听器
var listener: IListener = {
    update: (result: string): void => {
        console.log(result);
    }
}

// 定义发布者
var publisher: IObserverable = {
    name: "12tall",
    listeners: new Array<IListener>(),
    addListener: (listener: IListener) => {
        publisher.listeners.push(listener);
    },
    notify: () => {
        publisher.listeners.forEach(listener => {
            listener.update(`name updated:${publisher.name}`);
        });
    }
}

// 发布者添加监听器
publisher.addListener(listener);

// 将某个属性变为可观测对象
// 可以写一个方法，把对象的所有属性都变成可观测的
defineReactive(publisher, "name", "12tall");

publisher.name = "12 and tall";
// name updated:12 and tall

```

当然，逐个属性设置比较灵活，但是也太费劲了，所以我们又引入了一个新的方法，就是上面提到的，把所有属性变成可观测的  

```ts
// listener.ts

/**
 * 将一个对象的所有属性转化为可观测的
 * @param {IObserverable} obj 目标对象
 * @summary Observer 方法应该是递归调用的
 */
function Observer(obj: IObserverable): void {
    if (obj && typeof obj === 'object') {
        Object.keys(obj).forEach((prop: string) => {
            defineReactive(obj, prop, obj[prop]);
        })
    }
}

Observer(publisher);

publisher.name = "12 and tall";
// name updated:12 and tall
```

但是有时候为了节约资源，提高效率。有些属性，我们想等到用到的时候再让它变得可观测，这样就可以减少不必要的操作。  

```vue
// 引用自掘金：https://juejin.im/book/5a36661851882538e2259c0f/section/5a3bb1636fb9a0452846aa50

new Vue({
    template:
        `<div>
            <span>{{text1}}</span>
            <span>{{text2}}</span>
        <div>`,
    data: {
        text1: 'text1',
        text2: 'text2',
        text3: 'text3'
    }
});
```

因为`text3` 不用在视图中显示，所以将它设置成可观测的就有些浪费了，所以我们需要引入`依赖收集`的概念：  

1. 在属性被读取(`get()`) 时，才转化为可观测的  
2. 如果属性D是通过其他属性S计算后得到的，那么属性S 变化也要通知到属性D

## 1. 复杂的发布者-订阅者模式(依赖收集)  

