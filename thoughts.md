# 一些想法  

## 加油  

没有验证过的想法都是胡扯。

- 关于任务调度  
或许可以采用时间段+中断的方式进行任务调度。以以读硬盘数据(耗时操作)为例：  

> 1 读取硬盘数据是系统调用，不应存在竞争关系(顺序操作)  
> 2 系统调用需要传入`PId` 来确定返回数据归属  
> 3 读取数据后，系统中断，将数据放入缓存，(一说将任务放到队列尾部，如果是多线程任务这样做是不合适的吧)  
> 4 将数据放入对应缓存(系统调用内判断是否读取成功)，然后紧接着执行下一个磁盘任务  

存在问题：  
> 1 如何合理规划延时任务与非延时任务之间的关系，可能这并不是一个问题  
> 2 算是轮询+中断吧  
> 3 进程内部采用协程？抛弃线程？  

- 进程切换为什么更耗时  

> 在x86 架构下，因为内存的分页机制：在保证每个任务(Task)享有`4GB` 内存空间的同时，如果物理内存不足需要将某些页存储至`虚拟内存`，也就是硬盘上，
> 在需要时重新加载至内存。而硬盘的读写操作速度相比内存差太多，于是任务切换时会更加耗时。  

解决方案：
> 减少任务体积，避免运行大任务(有点废话，不能强求)  
> 尽量充分利用物理内存！

- 线程与异步(C# 为例)  

> 线程的切换是由操作系统调度的，会耗费额外的cpu 时间；异步更像是回调函数，利用中断来执行(I/O 中也是这么做的)  
> `DMA`：直接内存访问。硬盘、网卡此类设备在DMA 模式下，一般可以直接操作内存，这样只需cpu 发出相关指令，待IO 完成后产生硬件中断来提醒cpu 取数据就好了  
> 异步一般适用于IO 操作，在UI 上异步仍然会阻塞线程  

## 乱七八糟  

### 关于操作系统  

似乎之前的重点一直在硬件层面，而没有考虑过软件层上的抽象。如果只关注细节的话，就算是精简指令集，一旦配合上复杂的外设，就会让人无所适从。这也要求我们需要自顶向下地考虑问题，设计方案。  
重点不在于使用哪种芯片，重点在于思路，对于任意平台的抽象能力。大胆猜一下，这是不是就是所谓的内核呢？  
(2019-06-05  

1 操作系统是什么  

> - 对机器的扩展：建立在硬件上的虚拟机  
> - 资源管理：协调各类硬件设备

### 关于表  

表真的是一个非常有用的(amazing)数据结构，前提是搭配上指针一起使用  

1 数组  
数组大概是最简单的表结构了  

> - 数组的下标(index)和内容(value)实际上是一个两列的数据表，其实叫字典更合适  
> - 如果value 存储的是函数的指针，配合上枚举类型，那么就是最简单的状态机  
> - 通过添加一个游标，可以用来实现简单的扫描示波器  

2 字典  
由键值对组成，键不能重复  

> - 可以通过键来搜索值  
> - 哈希表其实就是一个字典  

3 链表  
链表相对于数组来说，插入和删除更简单了，但是查询的效率变低，不能进行随机读取  

> - 双向链表：游标可以自由的前后移动  
> - 环表(循环链表)：首尾相接的链表，游标可以循环利用，最典型的应用是用来解决[约瑟夫问题](https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98)  

4 数组+链表(只记得听说过应用，但是具体例子不记得了)  
主要用于解决数组增删不便，链表难以查询的问题。采取的是一种折中的方案：  

> - 最上层采用数组做索引  
> - 数组元素指向相应的链表，这样便能最快缩小查询范围，然后通过遍历链表执行增删改查操作  
> - 组合方式可以是：每个数组元素指向一个对立的链表；也可以是指向一个大链表的一个节点(可以避免数据过于集中的问题吧，个人想的，没做过验证)  

5 散列表  
感觉散列表其实和数组差不多，所谓散列，就是将元素均匀地分布在(有序地)容器上，时间复杂度为`O(1)`哦  

> 散列函数：未必就是128位的哈希编码函数。如果要对26 个字母选择一个散列函数，那么`f=x-41h` 应该是一个更好的选择  
> 填充因子：已填充元素数量 / 容器容量；一般小于1，但是也有可能大于1(当元素其实是一个链表时)  
> 长度调整：散列表长度调整是比较耗时的  

6 栈与队列  
这里的栈和队列虽然工作原理与硬件一致，但更多的是软件的实现，以兼容更高级的数据结构  

> - 栈(`stack`)：`FILO` 先入后出，后来居上  
> - 队列(`queue`)：`FIFO` 先入先出
> - 栈和队列最好带有一个哨兵，用以标识栈底和队尾  

注：哨兵  
用于判断游标是否越界

> - 字符串的结尾`\0` 就是一个哨兵
> - 尽量减少频繁的无意义的`判断`操作。因为判断语句在`for` 循环中最为常用，尤其是对数据是否越界的判断  
> - `达夫设备` 也是利用`switch` 的跌落特性，来减少判断语句的执行次数的  
> - 为什么总提`达夫设备`？因为真的是太神奇了，在机器指令的层面上，真的可以为所欲为！完全忽略掉高级语言语法的掣肘~

7 树  
相对于链表，树的每个节点可能会对应着更多的子节点。树结构应该是对于链表的扩展吧，个人觉得是的  

> - 树是一种递归结构
> - 树状结构最常用来存储有组织关系的数据：文件目录、部门科室  
> - 比较有名的：普通树(最常用吧)、二叉树、AVL树、红黑树

8 图  
树的连接是单向的，但是图允许个节点互相连接  

> - 有向图/无向图
> - 目前个人感觉能用到的地方就是状态机。。。  

附一个挺好的[链接](https://www.cnblogs.com/jingcaijueyan/p/9456072.html)

### 关于存储设备  

1 文件系统  
大概是为了方便资源管理吧  

> - 一般文件系统的类型写在分区的标识符里  
> - 硬盘应该还有一个分区表才对吧
