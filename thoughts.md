# 一些想法  

## 加油  

没有验证过的想法都是胡扯。

- 关于任务调度  
或许可以采用时间段+中断的方式进行任务调度。以以读硬盘数据(耗时操作)为例：  

> 1 读取硬盘数据是系统调用，不应存在竞争关系(顺序操作)  
> 2 系统调用需要传入`PId` 来确定返回数据归属  
> 3 读取数据后，系统中断，将数据放入缓存，(一说将任务放到队列尾部，如果是多线程任务这样做是不合适的吧)  
> 4 将数据放入对应缓存(系统调用内判断是否读取成功)，然后紧接着执行下一个磁盘任务  

存在问题：  
> 1 如何合理规划延时任务与非延时任务之间的关系，可能这并不是一个问题  
> 2 算是轮询+中断吧  
> 3 进程内部采用协程？抛弃线程？  

- 进程切换为什么更耗时  

> 在x86 架构下，因为内存的分页机制：在保证每个任务(Task)享有`4GB` 内存空间的同时，如果物理内存不足需要将某些页存储至`虚拟内存`，也就是硬盘上，
> 在需要时重新加载至内存。而硬盘的读写操作速度相比内存差太多，于是任务切换时会更加耗时。  

解决方案：
> 减少任务体积，避免运行大任务(有点废话，不能强求)  
> 尽量充分利用物理内存！

- 线程与异步(C# 为例)  

> 线程的切换是由操作系统调度的，会耗费额外的cpu 时间；异步更像是回调函数，利用中断来执行(I/O 中也是这么做的)  
> `DMA`：直接内存访问。硬盘、网卡此类设备在DMA 模式下，一般可以直接操作内存，这样只需cpu 发出相关指令，待IO 完成后产生硬件中断来提醒cpu 取数据就好了  
> 异步一般适用于IO 操作，在UI 上异步仍然会阻塞线程  

## 乱七八糟  

### 关于操作系统  

似乎之前的重点一直在硬件层面，而没有考虑过软件层上的抽象。如果只关注细节的话，就算是精简指令集，一旦配合上复杂的外设，就会让人无所适从。这也要求我们需要自顶向下地考虑问题，设计方案。  
重点不在于使用哪种芯片，重点在于思路，对于任意平台的抽象能力。大胆猜一下，这是不是就是所谓的内核呢？  
(2019-06-05  

1 操作系统是什么  

> - 对机器的扩展：建立在硬件上的虚拟机  
> - 资源管理：协调各类硬件设备

### 关于表  

表真的是一个非常有用的(amazing)数据结构，前提是搭配上指针一起使用  

1 数组  
数组大概是最简单的表结构了  

> - 数组的下标(index)和内容(value)实际上是一个两列的数据表，其实叫字典更合适  
> - 如果value 存储的是函数的指针，配合上枚举类型，那么就是最简单的状态机  
> - 通过添加一个游标，可以用来实现简单的扫描示波器  

2 字典  
由键值对组成，键不能重复  

> - 可以通过键来搜索值  
> - 哈希表其实就是一个字典  

3 链表  
链表相对于数组来说，插入和删除更简单了，但是查询的效率变低，不能进行随机读取  

> - 双向链表：游标可以自由的前后移动  
> - 环表(循环链表)：首尾相接的链表，游标可以循环利用，最典型的应用是用来解决[约瑟夫问题](https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98)  

4 数组+链表(只记得听说过应用，但是具体例子不记得了)  
主要用于解决数组增删不便，链表难以查询的问题。采取的是一种折中的方案：  

> - 最上层采用数组做索引  
> - 数组元素指向相应的链表，这样便能最快缩小查询范围，然后通过遍历链表执行增删改查操作  
> - 组合方式可以是：每个数组元素指向一个对立的链表；也可以是指向一个大链表的一个节点(可以避免数据过于集中的问题吧，个人想的，没做过验证)  

5 散列表  
感觉散列表其实和数组差不多，所谓散列，就是将元素均匀地分布在(有序地)容器上，时间复杂度为`O(1)`哦  

> 散列函数：未必就是128位的哈希编码函数。如果要对26 个字母选择一个散列函数，那么`f=x-41h` 应该是一个更好的选择  
> 填充因子：已填充元素数量 / 容器容量；一般小于1，但是也有可能大于1(当元素其实是一个链表时)  
> 长度调整：散列表长度调整是比较耗时的  

6 栈与队列  
这里的栈和队列虽然工作原理与硬件一致，但更多的是软件的实现，以兼容更高级的数据结构  

> - 栈(`stack`)：`FILO` 先入后出，后来居上  
> - 队列(`queue`)：`FIFO` 先入先出
> - 栈和队列最好带有一个哨兵，用以标识栈底和队尾  

注：哨兵  
用于判断游标是否越界

> - 字符串的结尾`\0` 就是一个哨兵
> - 尽量减少频繁的无意义的`判断`操作。因为判断语句在`for` 循环中最为常用，尤其是对数据是否越界的判断  
> - `达夫设备` 也是利用`switch` 的跌落特性，来减少判断语句的执行次数的  
> - 为什么总提`达夫设备`？因为真的是太神奇了，在机器指令的层面上，真的可以为所欲为！完全忽略掉高级语言语法的掣肘~

7 树  
相对于链表，树的每个节点可能会对应着更多的子节点。树结构应该是对于链表的扩展吧，个人觉得是的  

特征：  

> - 树是一种递归结构  
> - 树状结构最常用来存储有组织关系的数据：文件目录、部门科室  
> - 比较有名的：普通树(最常用吧)、二叉树、AVL树、红黑树

细分：  

> - 二叉树：每个节点最多有两个子节点的树  
> - 二叉查找树：对于每个节点，其左侧子节点的值小，右侧子节点的值大  
> - [AVL 树](https://www.cnblogs.com/idreamo/p/8308336.html)：在二叉查找树的基础上，每个节点存储`节点平衡因子`(左侧子树高度-右侧子树高度)，在高度失衡时可以通过`AVL 旋转`自动平衡  
> - 红黑树：~~在AVL树的基础上，平衡因子为`2n`~~ 不太确定  
> - 2-3 树：在AVL 树的基础上，每个节点最多可以存放2个值，每个节点最多有3个节点  
> - [B 树](https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html)：在2-3 树的基础上对于`M`阶B 树，每个节点允许有`M-1`个子节点，主要用在数据库索引和一些对硬盘操作比较多的情况。链接内的动画演示更直观一些  
> - B+ 树：相较于B 树，B+ 树所有信息存放在叶子节点上，其他节点只做索引用；所有叶子节点形成一个链表，如果要遍历B+ 树，只需要遍历一遍叶子节点  

8 图  
树的连接是单向的，但是图允许个节点互相连接  

> - 有向图/无向图
> - 目前个人感觉能用到的地方就是状态机。。。  

附一个挺好的[链接](https://www.cnblogs.com/jingcaijueyan/p/9456072.html)

### 关于存储设备  

1 文件系统  
大概是为了方便资源管理吧  

> - 一般文件系统的类型写在分区的标识符里  
> - 硬盘应该还有一个分区表才对吧

### 关于包依赖  

刚开始的时候功能少，包管理还比较简单，随着功能的增加，包引用的越来越多，就可能会出现依赖项不可控，版本混乱，冲突。尽管有自动化的包管理工具可用，但是整个项目的清晰度其实是下降了的。  
怎么说呢，只是个人的想法吧：  

- 少引用包  
- 引用最基本的包  

### 关于组织架构  

在关系型数据库中，数据均是以记录的形式存在：一条记录对应着一个实体对象。这也造成了难以用`SQL` 直接查询出树状结构。  
仔细想一下，这块地方主要存在着三个难点：  

1. 父子关系在数据库中如何表示  
2. 如何最快地构造一棵组织树  
3. 如何进行增删改查、结点变更的操作  

#### 数据表设计  

一般的话，数据表中会有一个字段来包含上级节点，例如：  
Id|pId|nName|comment
---|---|---|---
0|-1|n1|root
1|0|n2|level 1  
2|1|n3|level 2  

生成树结构的时候需要递归的遍历每个节点。

> 扩展【关于中间表】：中间表似乎就是为了处理数据表之间一对多、多对多关系而存在的  
> 中间表最少只包含两列，分别存放另外两个表的主键，大概就是这个样子  
> name|goods  
> ---|---
> tom|pen
> tom|pencil
> jerry|knife  
> jerry|pencil  
>
> 如果一个中间表的左右两列都来源于同一个表，那么我们可以管它叫做`闭包表`。  
> 我也不知道这个称呼代表着什么意思~，但是用闭包表来表示树状结构确实很方便增删改查  
>
> pNodeId|sNodeId|comment
> ---|---|---  
> 0|0|root
> 0|1|root -> node1(lvl1)
> 1|1|node1
> 0|2|root -> node2(lvl2)
> 1|2|node1(lvl1) -> node2(lvl2)
> 2|2|node2
> 0|3|root -> node3(lvl1)
> 3|3|node3  
>
> 稍微考虑一下：树越深，闭包表的膨胀速度就会越快。  
> 最坏的情况是`row = n(n+1)/2, n=节点数`  

如果不用中间表的话，我们还可以在`运行内存(堆/heap)` 中动手脚，请以第一个表为例：  

1. 新建一个静态(全局)的`HashTable<Node>` 用以存放所有记录  
2. 遍历该哈希表，依照`pId` 字段查找父节点，并将该节点添加至父节点`children` 属性  
3. 这样就通过一次遍历生成了一棵组织树，而这棵树只有在节点发生变化时才会被修改，平时就常驻内存就好了  
4. 一个不太方便的地方就是在删除一个节点时，需要先递归地删除每个子结点及其子结点  
5. 当然，也可以递归地获取子结点`id` 一次查询删除  

这大概是能想到的最好地方法了  

### 关于项目文件组织  

强烈建议接口与实体类写在两个类库里面：  

```txt
+ Entitis(类库，A 维护)
  + User
  + Apple
  + Orange
  ...
+ Interfaces(类库，B 维护)
  + IUser
  + IFruit
  + IOrange
  ...
```  

这样的一个好处就是，接口和实体类可以分开维护。处理业务的人(B)无需再去关心对象方法的实现，也可以快速实现一个项目的原型。首先约定好对象方法，然后两头施工就可以了。  
而且一旦来了新人，也可以让新人帮忙打下手去实现对象方法什么的(慢慢熟悉项目)，即使不了解项目，也能帮得上忙，感觉这是个好的想法与习惯。

### 命名与脚本语言与委托、指针  

关于这一块还不能很好的描述~

> 指针是一个很神奇的存在。我们可以把函数的指针存放在一个数组里面，这样就可以根据参数去判断使用数组中的哪一个函数去处理了~  
> 鉴于脚本语言一般是通过字符串来确定一个属性的，所以存在着一些投机取巧行为，将参数拼接进字符串来确定使用那个函数来处理数据~  
