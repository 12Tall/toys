# 一些想法  

## 加油  

没有验证过的想法都是胡扯。

- 关于任务调度  
或许可以采用时间段+中断的方式进行任务调度。以以读硬盘数据(耗时操作)为例：  

> 1 读取硬盘数据是系统调用，不应存在竞争关系(顺序操作)  
> 2 系统调用需要传入`PId` 来确定返回数据归属  
> 3 读取数据后，系统中断，将数据放入缓存，(一说将任务放到队列尾部，如果是多线程任务这样做是不合适的吧)  
> 4 将数据放入对应缓存(系统调用内判断是否读取成功)，然后紧接着执行下一个磁盘任务  

存在问题：  
> 1 如何合理规划延时任务与非延时任务之间的关系，可能这并不是一个问题  
> 2 算是轮询+中断吧  
> 3 进程内部采用协程？抛弃线程？  

## 乱七八糟  

### 关于操作系统  

似乎之前的重点一直在硬件层面，而没有考虑过软件层上的抽象。如果只关注细节的话，就算是精简指令集，一旦配合上复杂的外设，就会让人无所适从。这也要求我们需要自顶向下地考虑问题，设计方案。  
重点不在于使用哪种芯片，重点在于思路，对于任意平台的抽象能力。大胆猜一下，这是不是就是所谓的内核呢？  
(2019-06-05  

### 关于表  

表真的是一个非常有用的(amazing)数据结构，前提是搭配上指针一起使用  

1 数组  
数组大概是最简单的表结构了  

> - 数组的下标(index)和内容(value)实际上是一个两列的数据表，其实叫字典更合适  
> - 如果value 存储的是函数的指针，配合上枚举类型，那么就是最简单的状态机  
> - 通过添加一个游标，可以用来实现简单的扫描示波器  

2 字典  
由键值对组成，键不能重复  

> - 可以通过键来搜索值  
> - 哈希表其实就是一个字典   

3 链表  
链表相对于数组来说，插入和删除更简单了，但是查询的效率变低，不能进行随机读取  

> - 双向链表：游标可以自由的前后移动  
> - 环表(循环链表)：首尾相接的链表，游标可以循环利用，最典型的应用是用来解决[约瑟夫问题](https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98)  

4 数组+链表(只记得听说过应用，但是具体例子不记得了)  
主要用于解决数组增删不便，链表难以查询的问题。采取的是一种折中的方案：  

> - 最上层采用数组做索引  
> - 数组元素指向相应的链表，这样便能最快缩小查询范围，然后通过遍历链表执行增删改查操作  
> - 组合方式可以是：每个数组元素指向一个对立的链表；也可以是指向一个大链表的一个节点(可以避免数据过于集中的问题吧，个人想的，没做过验证)  

5 栈与队列  
这里的栈和队列虽然工作原理与硬件一致，但更多的是软件的实现，以兼容更高级的数据结构  

> - 栈(`stack`)：`FILO` 先入后出，后来居上  
> - 队列(`queue`)：`FIFO` 先入先出
> - 栈和队列最好带有一个哨兵，用以标识栈底和队尾  

注：哨兵  
用于判断游标是否越界

> - 字符串的结尾`\0` 就是一个哨兵
> - 尽量减少频繁的无意义的`判断`操作。因为判断语句在`for` 循环中最为常用，尤其是对数据是否越界的判断  
> - `达夫设备` 也是利用`switch` 的跌落特性，来减少判断语句的执行次数的  
> - 为什么总提`达夫设备`？因为真的是太神奇了，在机器指令的层面上，真的可以为所欲为！完全忽略掉高级语言语法的掣肘~

6 树  
相对于链表，树的每个节点可能会对应着更多的子节点。树结构应该是对于链表的扩展吧，个人觉得是的  

> - 树是一种递归结构
> - 树状结构最常用来存储有组织关系的数据：文件目录、部门科室  
> - 比较有名的：普通树(最常用吧)、二叉树、AVL树、红黑树

7 图  
树的连接是单向的，但是图允许个节点互相连接  

> - 有向图/无向图
> - 目前个人感觉能用到的地方就是状态机。。。  

附一个挺好的[链接](https://www.cnblogs.com/jingcaijueyan/p/9456072.html)
